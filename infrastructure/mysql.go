package infrastructure

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/koyuta/go-application-sample/interfaces/repository"
)

// MySQLHandler acts as the MySQL client.
type MySQLHandler struct {
	conn *sql.DB
}

// NewMsHandler returns a new MySQLHandler. It invokes panic if some error occurerd.
func NewMySQLHandler(user, passwd, host string, port int, dbname string) (*MySQLHandler, error) {
	uri := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true", user, passwd, host, port, dbname)
	conn, err := sql.Open("mysql", uri)
	if err != nil {
		return nil, err
	}

	return &MySQLHandler{conn: conn}, err
}

// Execute execute a query via Conn.Exec function. It expects
// to use CREATE, UPDATE, DELETE commands.
func (m *MySQLHandler) Execute(query string, args ...interface{}) (repository.Result, error) {
	res, err := m.conn.Exec(query, args...)
	if err != nil {
		return new(Result), err
	}
	return &Result{Result: res}, nil
}

// ExecuteContext execute a query via Conn.ExecContext function. It expects
// to use CREATE, UPDATE, DELETE commands.
func (m *MySQLHandler) ExecuteContext(ctx context.Context, query string, args ...interface{}) (repository.Result, error) {
	res, err := m.conn.ExecContext(ctx, query, args...)
	if err != nil {
		return new(Result), err
	}
	return &Result{Result: res}, nil
}

// Query execute a query via Conn.Query function.
// It expects to use SELECT command.
func (m *MySQLHandler) Query(query string, args ...interface{}) (repository.Rows, error) {
	res, err := m.conn.Query(query, args...)
	if err != nil {
		return new(Rows), err
	}
	return &Rows{Rows: res}, nil
}

// QueryContext execute a query via Conn.QueryContext function.
// It expects to use SELECT command.
func (m *MySQLHandler) QueryContext(ctx context.Context, query string, args ...interface{}) (repository.Rows, error) {
	res, err := m.conn.QueryContext(ctx, query, args...)
	if err != nil {
		return new(Rows), err
	}
	return &Rows{Rows: res}, nil
}

// Result represents the result of a query.
type Result struct {
	Result sql.Result
}

// LastInsertId returns a integer generated by the database
// in response to a command.
func (r *Result) LastInsertId() (int64, error) {
	return r.Result.LastInsertId()
}

// RowsAffected returns the number of rows affected.
func (r *Result) RowsAffected() (int64, error) {
	return r.Result.RowsAffected()
}

// Rows represents the result of a query.
type Rows struct {
	Rows *sql.Rows
}

// Scan assigns a value from database.
func (r *Rows) Scan(dest ...interface{}) error {
	return r.Rows.Scan(dest...)
}

// Next prepares the next result row for reading with the Scan.
func (r *Rows) Next() bool {
	return r.Rows.Next()
}

// Close closes the Rows, preventing further enumeration.
func (r *Rows) Close() error {
	return r.Rows.Close()
}
